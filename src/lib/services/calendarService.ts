import { DetailedItinerary } from './geminiService';

export async function createCalendarEvent(itinerary: DetailedItinerary): Promise<string> {
  try {
    // Create a Google Calendar event URL
    const startDate = new Date(itinerary.date);
    const endDate = new Date(startDate);
    endDate.setHours(startDate.getHours() + 4); // Assume 4-hour date
    
    // Format dates for Google Calendar URL
    const startTime = formatDateForCalendar(startDate);
    const endTime = formatDateForCalendar(endDate);
    
    // Create event description
    const description = createEventDescription(itinerary);
    
    // Create location (use first location from timeline)
    const location = itinerary.timeline[0]?.location || 'Vancouver, BC';
    
    // Generate Google Calendar URL
    const calendarUrl = new URL('https://calendar.google.com/calendar/render');
    calendarUrl.searchParams.set('action', 'TEMPLATE');
    calendarUrl.searchParams.set('text', itinerary.title);
    calendarUrl.searchParams.set('dates', `${startTime}/${endTime}`);
    calendarUrl.searchParams.set('details', description);
    calendarUrl.searchParams.set('location', location);
    calendarUrl.searchParams.set('sf', 'true');
    calendarUrl.searchParams.set('output', 'xml');
    
    return calendarUrl.toString();
    
  } catch (error) {
    console.error('Error creating calendar event:', error);
    throw new Error('Failed to create calendar event');
  }
}

function formatDateForCalendar(date: Date): string {
  // Format: YYYYMMDDTHHMMSSZ
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
}

function createEventDescription(itinerary: DetailedItinerary): string {
  let description = `${itinerary.title}\\n\\n`;
  description += `ðŸ’° Estimated Cost: $${itinerary.totalEstimatedCost}\\n\\n`;
  description += `ðŸ“… ITINERARY:\\n`;
  
  itinerary.timeline.forEach(item => {
    description += `${item.time} - ${item.activity}\\n`;
    description += `ðŸ“ ${item.location}\\n`;
    description += `â±ï¸ Duration: ${item.duration}\\n`;
    if (item.notes) {
      description += `ðŸ“ ${item.notes}\\n`;
    }
    
    // Add links
    if (item.links.reservation) {
      description += `ðŸ½ï¸ Reservation: ${item.links.reservation}\\n`;
    }
    if (item.links.booking) {
      description += `ðŸŽ« Booking: ${item.links.booking}\\n`;
    }
    if (item.links.directions) {
      description += `ðŸ—ºï¸ Directions: ${item.links.directions}\\n`;
    }
    description += `\\n`;
  });
  
  if (itinerary.tips.length > 0) {
    description += `ðŸ’¡ TIPS:\\n`;
    itinerary.tips.forEach(tip => {
      description += `â€¢ ${tip}\\n`;
    });
    description += `\\n`;
  }
  
  if (itinerary.emergencyContacts.length > 0) {
    description += `ðŸ“ž EMERGENCY CONTACTS:\\n`;
    itinerary.emergencyContacts.forEach(contact => {
      description += `â€¢ ${contact}\\n`;
    });
  }
  
  description += `\\n\\nGenerated by DatePlanner ðŸ’•`;
  
  return description;
}

// Alternative: Create .ics file for broader calendar compatibility
export async function createICSFile(itinerary: DetailedItinerary): Promise<string> {
  const startDate = new Date(itinerary.date);
  const endDate = new Date(startDate);
  endDate.setHours(startDate.getHours() + 4);
  
  const icsContent = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//DatePlanner//EN',
    'BEGIN:VEVENT',
    `UID:${Date.now()}@dateplanner.app`,
    `DTSTART:${formatDateForICS(startDate)}`,
    `DTEND:${formatDateForICS(endDate)}`,
    `SUMMARY:${itinerary.title}`,
    `DESCRIPTION:${createEventDescription(itinerary).replace(/\\n/g, '\\n')}`,
    `LOCATION:${itinerary.timeline[0]?.location || 'Vancouver, BC'}`,
    'STATUS:CONFIRMED',
    'END:VEVENT',
    'END:VCALENDAR'
  ].join('\\r\\n');
  
  return icsContent;
}

function formatDateForICS(date: Date): string {
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}Z/, 'Z');
}